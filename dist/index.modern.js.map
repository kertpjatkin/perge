{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import Peer from 'peerjs'\nimport * as Automerge from 'automerge'\n\nexport interface PergeConfig {\n  decode?: (msg: string) => any\n  encode?: (msg: any) => string\n  peer?: Peer\n  docSet?: Automerge.DocSet<any>\n}\n\nexport default class Perge {\n  readonly peer: Peer\n  readonly docSet: Automerge.DocSet<any>\n\n  private _connections: { [id: string]: Automerge.Connection<any> } = {}\n  private _actorId: string\n  private _encode: (msg: any) => string\n  private _decode: (msg: string) => any\n\n  constructor(actorId: string, config: PergeConfig = {}) {\n    this._actorId = actorId\n    this.peer = config.peer || new Peer(this._actorId)\n    this.docSet = config.docSet || new Automerge.DocSet()\n    this._encode = config.encode || JSON.stringify\n    this._decode = config.decode || JSON.parse\n    this.peer.on('connection', conn => {\n      conn.on('data', msg => {\n        this._connections[conn.peer].receiveMsg(this._decode(msg))\n      })\n    })\n  }\n\n  public connect(id: string, conn?: Peer.DataConnection): Peer.DataConnection {\n    if (this._connections[id]) return this.peer.connections[id]\n    const peer = conn || this.peer.connect(id)\n    const connection = this._connections[id] = new Automerge.Connection(this.docSet, msg => {\n      peer.send(this._encode(msg))\n    })\n    peer.on('disconnected', () => {\n      connection.close()\n      delete this._connections[id]\n    })\n    connection.open()\n    return peer\n  }\n\n  public select<T>(id: string): (fn: Function, ...args: any[]) => Automerge.Doc<T> {\n    const doc = this.docSet.getDoc(id) || Automerge.init(this._actorId)\n    return (fn: Function, ...args: any[]): Automerge.Doc<T> => {\n      const newDoc = fn(doc, ...args)\n      this.docSet.setDoc(id, newDoc)\n      return newDoc\n    }\n  }\n\n  public subscribe<T>(idOrSetHandler: string | Automerge.DocSetHandler<T>, callback?: Automerge.ChangeFn<T>): () => void {\n    if (typeof idOrSetHandler === 'function') {\n      this.docSet.registerHandler(idOrSetHandler)\n      return () => this.docSet.unregisterHandler(idOrSetHandler)\n    }\n    if (typeof idOrSetHandler === 'string' && !!callback) {\n      const handler = (docId: string, doc: T) => {\n        if (docId === idOrSetHandler) callback(doc)\n      }\n      this.docSet.registerHandler(handler)\n      return () => this.docSet.unregisterHandler(handler)\n    }\n    return () => { }\n  }\n}\n"],"names":["constructor","actorId","config","this","_actorId","peer","Peer","docSet","Automerge","_encode","encode","JSON","stringify","_decode","decode","parse","on","conn","msg","_connections","receiveMsg","connect","id","connections","connection","send","close","open","select","doc","getDoc","fn","args","newDoc","setDoc","subscribe","idOrSetHandler","callback","registerHandler","unregisterHandler","handler","docId"],"mappings":"wGAmBEA,YAAYC,EAAiBC,EAAsB,IAL3CC,kBAA4D,GAMlEA,KAAKC,SAAWH,EAChBE,KAAKE,KAAOH,EAAOG,MAAQ,IAAIC,EAAKH,KAAKC,UACzCD,KAAKI,OAASL,EAAOK,QAAU,IAAIC,EACnCL,KAAKM,QAAUP,EAAOQ,QAAUC,KAAKC,UACrCT,KAAKU,QAAUX,EAAOY,QAAUH,KAAKI,MACrCZ,KAAKE,KAAKW,GAAG,aAAcC,IACzBA,EAAKD,GAAG,OAAQE,IACdf,KAAKgB,aAAaF,EAAKZ,MAAMe,WAAWjB,KAAKU,QAAQK,QAKpDG,QAAQC,EAAYL,GACzB,GAAId,KAAKgB,aAAaG,GAAK,YAAYjB,KAAKkB,YAAYD,GACxD,MAAMjB,EAAOY,GAAQd,KAAKE,KAAKgB,QAAQC,GACjCE,EAAarB,KAAKgB,aAAaG,GAAM,IAAId,EAAqBL,KAAKI,OAAQW,IAC/Eb,EAAKoB,KAAKtB,KAAKM,QAAQS,MAOzB,OALAb,EAAKW,GAAG,eAAgB,KACtBQ,EAAWE,oBACCP,aAAaG,KAE3BE,EAAWG,OACJtB,EAGFuB,OAAUN,GACf,MAAMO,EAAM1B,KAAKI,OAAOuB,OAAOR,IAAOd,EAAeL,KAAKC,UAC1D,MAAO,CAAC2B,KAAiBC,KACvB,MAAMC,EAASF,EAAGF,KAAQG,GAE1B,OADA7B,KAAKI,OAAO2B,OAAOZ,EAAIW,GAChBA,GAIJE,UAAaC,EAAqDC,GACvE,GAA8B,mBAAnBD,EAET,OADAjC,KAAKI,OAAO+B,gBAAgBF,GACrB,IAAMjC,KAAKI,OAAOgC,kBAAkBH,GAE7C,GAA8B,iBAAnBA,GAAiCC,EAAU,CACpD,MAAMG,EAAU,CAACC,EAAeZ,KAC1BY,IAAUL,GAAgBC,EAASR,IAGzC,OADA1B,KAAKI,OAAO+B,gBAAgBE,GACrB,IAAMrC,KAAKI,OAAOgC,kBAAkBC,GAE7C,MAAO"}