{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import Peer from 'peerjs'\nimport * as Automerge from 'automerge'\n\nexport interface PergeConfig {\n  decode?: (msg: string) => any\n  encode?: (msg: any) => string\n  peer?: Peer\n  docSet?: Automerge.DocSet<any>\n}\n\nexport default class Perge {\n  readonly peer: Peer\n  readonly docSet: Automerge.DocSet<any>\n\n  private _connections: { [id: string]: Automerge.Connection<any> } = {}\n  private _actorId: string\n  private _encode: (msg: any) => string\n  private _decode: (msg: string) => any\n\n  constructor(actorId: string, config: PergeConfig = {}) {\n    this._actorId = actorId\n    this.peer = config.peer || new Peer(this._actorId)\n    this.docSet = config.docSet || new Automerge.DocSet()\n    this._encode = config.encode || JSON.stringify\n    this._decode = config.decode || JSON.parse\n    this.peer.on('connection', conn => {\n      conn.on('data', msg => {\n        this._connections[conn.peer].receiveMsg(this._decode(msg))\n      })\n    })\n  }\n\n  public connect(id: string, conn?: Peer.DataConnection): Peer.DataConnection {\n    if (this._connections[id]) return this.peer.connections[id]\n    const peer = conn || this.peer.connect(id)\n    const connection = this._connections[id] = new Automerge.Connection(this.docSet, msg => {\n      peer.send(this._encode(msg))\n    })\n    peer.on('disconnected', () => {\n      connection.close()\n      delete this._connections[id]\n    })\n    connection.open()\n    return peer\n  }\n\n  public select<T>(id: string): (fn: Function, ...args: any[]) => Automerge.Doc<T> {\n    const doc = this.docSet.getDoc(id) || Automerge.init(this._actorId)\n    return (fn: Function, ...args: any[]): Automerge.Doc<T> => {\n      const newDoc = fn(doc, ...args)\n      this.docSet.setDoc(id, newDoc)\n      return newDoc\n    }\n  }\n\n  public subscribe<T>(idOrSetHandler: string | Automerge.DocSetHandler<T>, callback?: Automerge.ChangeFn<T>): () => void {\n    if (typeof idOrSetHandler === 'function') {\n      this.docSet.registerHandler(idOrSetHandler)\n      return () => this.docSet.unregisterHandler(idOrSetHandler)\n    }\n    if (typeof idOrSetHandler === 'string' && !!callback) {\n      const handler = (docId: string, doc: T) => {\n        if (docId === idOrSetHandler) callback(doc)\n      }\n      this.docSet.registerHandler(handler)\n      return () => this.docSet.unregisterHandler(handler)\n    }\n    return () => { }\n  }\n}\n"],"names":["actorId","config","this","_actorId","peer","Peer","docSet","Automerge","_encode","encode","JSON","stringify","_decode","decode","parse","on","conn","msg","_this2","_connections","receiveMsg","connect","id","connections","connection","send","_this3","close","open","select","doc","getDoc","fn","newDoc","_this","setDoc","subscribe","idOrSetHandler","callback","registerHandler","_this4","unregisterHandler","handler","docId"],"mappings":"uVAmBE,WAAYA,EAAiBC,uBAAAA,IAAAA,EAAsB,IAL3CC,kBAA4D,GAMlEA,KAAKC,SAAWH,EAChBE,KAAKE,KAAOH,EAAOG,MAAQ,IAAIC,EAAKH,KAAKC,UACzCD,KAAKI,OAASL,EAAOK,QAAU,IAAIC,SACnCL,KAAKM,QAAUP,EAAOQ,QAAUC,KAAKC,UACrCT,KAAKU,QAAUX,EAAOY,QAAUH,KAAKI,MACrCZ,KAAKE,KAAKW,GAAG,aAAc,SAAAC,GACzBA,EAAKD,GAAG,OAAQ,SAAAE,GACdC,EAAKC,aAAaH,EAAKZ,MAAMgB,WAAWF,EAAKN,QAAQK,mCAKpDI,QAAA,SAAQC,EAAYN,cACzB,GAAId,KAAKiB,aAAaG,GAAK,YAAYlB,KAAKmB,YAAYD,GACxD,IAAMlB,EAAOY,GAAQd,KAAKE,KAAKiB,QAAQC,GACjCE,EAAatB,KAAKiB,aAAaG,GAAM,IAAIf,aAAqBL,KAAKI,OAAQ,SAAAW,GAC/Eb,EAAKqB,KAAKC,EAAKlB,QAAQS,MAOzB,OALAb,EAAKW,GAAG,eAAgB,WACtBS,EAAWG,eACJD,EAAKP,aAAaG,KAE3BE,EAAWI,OACJxB,KAGFyB,OAAA,SAAUP,cACTQ,EAAM5B,KAAKI,OAAOyB,OAAOT,IAAOf,OAAeL,KAAKC,UAC1D,gBAAQ6B,GACN,IAAMC,EAASD,gBAAGF,uCAElB,OADAI,EAAK5B,OAAO6B,OAAOb,EAAIW,GAChBA,MAIJG,UAAA,SAAaC,EAAqDC,cACvE,GAA8B,mBAAnBD,EAET,OADAnC,KAAKI,OAAOiC,gBAAgBF,qBACfG,EAAKlC,OAAOmC,kBAAkBJ,IAE7C,GAA8B,iBAAnBA,GAAiCC,EAAU,CACpD,IAAMI,EAAU,SAACC,EAAeb,GAC1Ba,IAAUN,GAAgBC,EAASR,IAGzC,OADA5B,KAAKI,OAAOiC,gBAAgBG,qBACfF,EAAKlC,OAAOmC,kBAAkBC,IAE7C"}